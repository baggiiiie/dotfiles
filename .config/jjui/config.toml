[keys]
# split = []
commit = []
[keys.preview]
toggle_bottom = []

[ui]
auto_refresh_interval = 30
enable_mouse = true
mouse_events = true

[ui.colors]
"selected" = { bold = true, bg = "#575048" }

[revisions]
# template = 'builtin_log_compact' # overrides jj's templates.log
# revset = "trunk():: & mine()"    # overrides jj's revsets.log

[preview]
position = "auto"
revision_command = [
    "show",
    "--color",
    "always",
    "-r",
    "$change_id",
    "--config",
    "ui.diff-formatter=delta-non-split-view",
]
file_command = [
    "diff",
    "--color",
    "always",
    "-r",
    "$change_id",
    "--config",
    "ui.diff-formatter=delta-non-split-view",
    # "ui.diff-formatter=difft-inline",
    "$file",
]
width_percentage = 60.0

[suggest]
[suggest.exec]
mode = "fuzzy"

[custom_commands]
[custom_commands.open_file]
key = ["O"]
lua = '''
local file = context.file()
if not file then
    flash("No file selected")
    return
end
exec_shell("nvim " .. file)
'''

[custom_commands.quick_revset]
key = ["ctrl+r"]
lua = '''
local selected = choose({
    options = {
        "mine()",
        "all()",
        "trunk()..@",
        revset.default()
    },
    title = "Quick Revset"
})

if selected then
    revset.set(selected)
    flash("Revset: " .. selected)
end
'''

[custom_commands.copy_to_clipboard]
key = ["Y"]
lua = '''
local checked_files = context.checked_files()
if checked_files and next(checked_files) ~= nil then
    local file_names = table.concat(checked_files, " ")
    copy_to_clipboard(file_names)
    flash("Copied checked files: " .. file_names)
    return
end
local selected_file = context.file()
if selected_file then
    copy_to_clipboard(selected_file)
    flash("Copied file: " .. selected_file)
    return
end
local change_id = context.change_id()
if change_id then
    copy_to_clipboard(change_id)
    flash("Copied change ID: " .. change_id)
    return
end
flash("No item selected to copy")
'''

[custom_commands.new_insert_after]
key = ["N"]
lua = '''
  jj("new", "-A", context.change_id())
  revisions.refresh()

  local new_change_id = jj("log", "-r", "@", "-T", "change_id.shortest()", "--no-graph")
  revisions.navigate{to=new_change_id}
  '''

[custom_commands.deltadiff]
key = ["d"]
args = [
    "util",
    "exec",
    "--",
    "bash",
    "-c",
    "/Users/ydai/Desktop/repos/personal/dotfiles/.config/jj/jj-diffnav.sh -r $change_id",
    # "-c",
    # "jj diff --git --color always -r $change_id $file | delta --pager 'less -R +g'",
]
show = "interactive"

# [custom_commands.split_test]
# key = ['s']
# lua = '''
# local checked_files = context.checked_files()
# if checked_files and next(checked_files) ~= nil then
#     jj_interactive("split", "-r", context.change_id(), "-m", "", unpack(checked_files))
#     flash('splited: ' .. table.concat(checked_files, ", "))
#     revisions.refresh({keep_selections = false})
#     return
# else
#     jj_interactive("split", "-r", context.change_id(), "-m", "")
# end
# '''

[custom_commands.commit]
key = ['c']
lua = '''
local applied = revisions.start_inline_describe()
local checked_files = context.checked_files()
if applied then
    jj("new", "-A", context.change_id())
    revisions.refresh()
    local new_change_id = jj("log", "-r", "@", "-T", "change_id.shortest()", "--no-graph")
    revisions.navigate{to=new_change_id}
    return
end
'''

[custom_commands.create_pr]
key = ["ctrl+p"]
lua = '''
local change_id = context.change_id()
if not change_id then
    flash("No revision selected")
    return
end

local template = 'if(self.present() && !remote, self.name() ++ "\n", "")'
local output = jj("bookmark", "list", "-r", change_id, "-T", template)
local bookmarks = {}
for line in output:gmatch("[^\n]+") do
    if line ~= "" then
        table.insert(bookmarks, line)
    end
end

local cmd = "/Users/ydai/Desktop/repos/personal/tries/2025-12-12-jj-git-integration/jj-create-pr.sh"
if #bookmarks > 0 then
    if #bookmarks > 1 then
        flash("Multiple bookmarks found, using: " .. bookmarks[1])
    end
    cmd = cmd .. " --branch " .. bookmarks[1]
end

exec_shell(cmd)
'''

[custom_commands.bookmarkabc]
key_sequence = ["w", "b"]
lua = '''
-- Get the current revision's change_id
template = 'if(self.present() && !remote, self.name() ++ "\n", "")'
local change_id = context.change_id()
if not change_id then
    flash("No revision selected")
    return
end

-- Get bookmarks on this revision
local output = jj("bookmark", "list", "-r", change_id, "-T", template)
local bookmarks = {}
for line in output:gmatch("[^\n]+") do
    if line ~= "" then
        table.insert(bookmarks, line)
    end
end

local function bookmark_operations(bookmark)
    local op = choose({options={"rename " .. bookmark, "delete " .. bookmark, "forget " .. bookmark}, title = "Select operation: "})
    if not op then return end

    if string.find(op, "rename") then
        local new_name = input({title="New bookmark name", value=bookmark})
        if new_name and new_name ~= "" then
            jj("bookmark", "rename", bookmark, new_name)
            revisions.refresh()
        end
    elseif string.find(op, "delete") then
        jj("bookmark", "delete", bookmark)
        revisions.refresh()
    elseif string.find(op, "forget") then
        jj("bookmark", "forget", bookmark)
        revisions.refresh()
    end
end

if #bookmarks == 0 then
    -- No bookmarks: show create/move menu
    local action = choose({options={"create bookmark", "move bookmark"}, title = "No bookmarks on revision"})
    if not action then return end

    if action == "create bookmark" then
        local name = input({title="New bookmark name"})
        if name and name ~= "" then
            jj("bookmark", "create", name, "-r", change_id)
            revisions.refresh()
        end
    elseif action == "move bookmark" then
        -- Get all bookmarks to move one here
        local all_output = jj("bookmark", "list", "-T", template)
        local all_bookmarks = {}
        for line in all_output:gmatch("[^\n]+") do
            if line ~= "" then
                table.insert(all_bookmarks, line)
            end
        end
        if #all_bookmarks == 0 then
            flash("No bookmarks to move")
            return
        end
        local to_move = choose({options=all_bookmarks, {title = "Select bookmark to move"}, filter=true})
        if to_move then
            local move_res, err = jj("bookmark", "move", to_move, "--to", change_id, "--allow-backwards")
            if err ~= nil then
                flash("Error moving bookmark: " .. err)
            else
                flash("Moved bookmark " .. move_res)
                revisions.refresh()
            end
        end
    end
elseif #bookmarks == 1 then
    -- Single bookmark: show operations directly
    bookmark_operations(bookmarks[1])
else
    -- Multiple bookmarks: let user pick one first
    local selected = choose({options=bookmarks, title = "Select bookmark"})
    if selected then
        bookmark_operations(selected)
    end
end
'''

[custom_commands.scroll_to_center]
key = ["Z"]
lua = '''
-- Center the currently selected revision on screen.
-- Adjust `half` to roughly half your terminal height.
local half = 15

local id = context.change_id()
if not id then return end

-- 1. Scroll viewport far down so cursor is above the visible area
revisions.scroll(100)
-- 2. Navigate back â€” ensureView snaps cursor to the top edge
revisions.navigate({ to = id })
-- 3. Scroll viewport up to push cursor from top toward center
revisions.scroll(-half)
'''
